// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct hushh_hcf_Product: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case description = 6
    case url = 8
    case categories = 10
    case vibes = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var hasCategories: Bool { let o = _accessor.offset(VTOFFSET.categories.v); return o == 0 ? false : true }
  public var categoriesCount: Int32 { let o = _accessor.offset(VTOFFSET.categories.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func categories(at index: Int32) -> hushh_hcf_Category? { let o = _accessor.offset(VTOFFSET.categories.v); return o == 0 ? nil : hushh_hcf_Category(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasVibes: Bool { let o = _accessor.offset(VTOFFSET.vibes.v); return o == 0 ? false : true }
  public var vibesCount: Int32 { let o = _accessor.offset(VTOFFSET.vibes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vibes(at index: Int32) -> hushh_hcf_Vibe? { let o = _accessor.offset(VTOFFSET.vibes.v); return o == 0 ? nil : hushh_hcf_Vibe(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startProduct(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func addVectorOf(categories: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: categories, at: VTOFFSET.categories.p) }
  public static func addVectorOf(vibes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vibes, at: VTOFFSET.vibes.p) }
  public static func endProduct(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createProduct(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    urlOffset url: Offset = Offset(),
    categoriesVectorOffset categories: Offset = Offset(),
    vibesVectorOffset vibes: Offset = Offset()
  ) -> Offset {
    let __start = hushh_hcf_Product.startProduct(&fbb)
    hushh_hcf_Product.add(id: id, &fbb)
    hushh_hcf_Product.add(description: description, &fbb)
    hushh_hcf_Product.add(url: url, &fbb)
    hushh_hcf_Product.addVectorOf(categories: categories, &fbb)
    hushh_hcf_Product.addVectorOf(vibes: vibes, &fbb)
    return hushh_hcf_Product.endProduct(&fbb, start: __start)
  }
  

  public mutating func unpack() -> hushh_hcf_ProductT {
    return hushh_hcf_ProductT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_ProductT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_ProductT) -> Offset {
    let __id: Offset
    if let s = obj.id {
      __id = builder.create(string: s)
    } else {
      __id = Offset()
    }

    let __description: Offset
    if let s = obj.description {
      __description = builder.create(string: s)
    } else {
      __description = Offset()
    }

    let __url: Offset
    if let s = obj.url {
      __url = builder.create(string: s)
    } else {
      __url = Offset()
    }

    var __categories__: [Offset] = []
    for var i in obj.categories {
      __categories__.append(hushh_hcf_Category.pack(&builder, obj: &i))
    }
    let __categories = builder.createVector(ofOffsets: __categories__)
    var __vibes__: [Offset] = []
    for var i in obj.vibes {
      __vibes__.append(hushh_hcf_Vibe.pack(&builder, obj: &i))
    }
    let __vibes = builder.createVector(ofOffsets: __vibes__)
    let __root = hushh_hcf_Product.startProduct(&builder)
    hushh_hcf_Product.add(id: __id, &builder)
    hushh_hcf_Product.add(description: __description, &builder)
    hushh_hcf_Product.add(url: __url, &builder)
    hushh_hcf_Product.addVectorOf(categories: __categories, &builder)
    hushh_hcf_Product.addVectorOf(vibes: __vibes, &builder)
    return hushh_hcf_Product.endProduct(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.categories.p, fieldName: "categories", required: false, type: ForwardOffset<Vector<ForwardOffset<hushh_hcf_Category>, hushh_hcf_Category>>.self)
    try _v.visit(field: VTOFFSET.vibes.p, fieldName: "vibes", required: false, type: ForwardOffset<Vector<ForwardOffset<hushh_hcf_Vibe>, hushh_hcf_Vibe>>.self)
    _v.finish()
  }
}

extension hushh_hcf_Product: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
    case description = "description"
    case url = "url"
    case categories = "categories"
    case vibes = "vibes"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(id, forKey: .id)
    try container.encodeIfPresent(description, forKey: .description)
    try container.encodeIfPresent(url, forKey: .url)
    if categoriesCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .categories)
      for index in 0..<categoriesCount {
        guard let type = categories(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if vibesCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .vibes)
      for index in 0..<vibesCount {
        guard let type = vibes(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
  }
}

public class hushh_hcf_ProductT: NativeObject {

  public var id: String?
  public var description: String?
  public var url: String?
  public var categories: [hushh_hcf_CategoryT?]
  public var vibes: [hushh_hcf_VibeT?]

  public init(_ _t: inout hushh_hcf_Product) {
    id = _t.id
    description = _t.description
    url = _t.url
    categories = []
    for index in 0..<_t.categoriesCount {
        var __v_ = _t.categories(at: index)
        categories.append(__v_?.unpack())
    }
    vibes = []
    for index in 0..<_t.vibesCount {
        var __v_ = _t.vibes(at: index)
        vibes.append(__v_?.unpack())
    }
  }

  public init() {
    categories = []
    vibes = []
  }

  public func serialize() -> ByteBuffer { return serialize(type: hushh_hcf_Product.self) }

}
public struct hushh_hcf_Category: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case description = 6
    case url = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public static func startCategory(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func endCategory(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCategory(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    urlOffset url: Offset = Offset()
  ) -> Offset {
    let __start = hushh_hcf_Category.startCategory(&fbb)
    hushh_hcf_Category.add(id: id, &fbb)
    hushh_hcf_Category.add(description: description, &fbb)
    hushh_hcf_Category.add(url: url, &fbb)
    return hushh_hcf_Category.endCategory(&fbb, start: __start)
  }
  

  public mutating func unpack() -> hushh_hcf_CategoryT {
    return hushh_hcf_CategoryT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_CategoryT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_CategoryT) -> Offset {
    let __id: Offset
    if let s = obj.id {
      __id = builder.create(string: s)
    } else {
      __id = Offset()
    }

    let __description: Offset
    if let s = obj.description {
      __description = builder.create(string: s)
    } else {
      __description = Offset()
    }

    let __url: Offset
    if let s = obj.url {
      __url = builder.create(string: s)
    } else {
      __url = Offset()
    }

    let __root = hushh_hcf_Category.startCategory(&builder)
    hushh_hcf_Category.add(id: __id, &builder)
    hushh_hcf_Category.add(description: __description, &builder)
    hushh_hcf_Category.add(url: __url, &builder)
    return hushh_hcf_Category.endCategory(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

extension hushh_hcf_Category: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
    case description = "description"
    case url = "url"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(id, forKey: .id)
    try container.encodeIfPresent(description, forKey: .description)
    try container.encodeIfPresent(url, forKey: .url)
  }
}

public class hushh_hcf_CategoryT: NativeObject {

  public var id: String?
  public var description: String?
  public var url: String?

  public init(_ _t: inout hushh_hcf_Category) {
    id = _t.id
    description = _t.description
    url = _t.url
  }

  public init() {
  }

  public func serialize() -> ByteBuffer { return serialize(type: hushh_hcf_Category.self) }

}
public struct hushh_hcf_Embedding: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case v = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasV: Bool { let o = _accessor.offset(VTOFFSET.v.v); return o == 0 ? false : true }
  public var vCount: Int32 { let o = _accessor.offset(VTOFFSET.v.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func v(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.v.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var v: [Float32] { return _accessor.getVector(at: VTOFFSET.v.v) ?? [] }
  public static func startEmbedding(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(v: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: v, at: VTOFFSET.v.p) }
  public static func endEmbedding(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEmbedding(
    _ fbb: inout FlatBufferBuilder,
    vVectorOffset v: Offset = Offset()
  ) -> Offset {
    let __start = hushh_hcf_Embedding.startEmbedding(&fbb)
    hushh_hcf_Embedding.addVectorOf(v: v, &fbb)
    return hushh_hcf_Embedding.endEmbedding(&fbb, start: __start)
  }
  

  public mutating func unpack() -> hushh_hcf_EmbeddingT {
    return hushh_hcf_EmbeddingT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_EmbeddingT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_EmbeddingT) -> Offset {
    let __v = builder.createVector(obj.v)
    let __root = hushh_hcf_Embedding.startEmbedding(&builder)
    hushh_hcf_Embedding.addVectorOf(v: __v, &builder)
    return hushh_hcf_Embedding.endEmbedding(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.v.p, fieldName: "v", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    _v.finish()
  }
}

extension hushh_hcf_Embedding: Encodable {

  enum CodingKeys: String, CodingKey {
    case v = "v"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if vCount > 0 {
      try container.encodeIfPresent(v, forKey: .v)
    }
  }
}

public class hushh_hcf_EmbeddingT: NativeObject {

  public var v: [Float32]

  public init(_ _t: inout hushh_hcf_Embedding) {
    v = []
    for index in 0..<_t.vCount {
        v.append(_t.v(at: index))
    }
  }

  public init() {
    v = []
  }

  public func serialize() -> ByteBuffer { return serialize(type: hushh_hcf_Embedding.self) }

}
public struct hushh_hcf_Vibe: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case description = 6
    case imageBase64 = 8
    case url = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var imageBase64: String? { let o = _accessor.offset(VTOFFSET.imageBase64.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageBase64SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageBase64.v) }
  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public static func startVibe(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func add(imageBase64: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageBase64, at: VTOFFSET.imageBase64.p) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func endVibe(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVibe(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    imageBase64Offset imageBase64: Offset = Offset(),
    urlOffset url: Offset = Offset()
  ) -> Offset {
    let __start = hushh_hcf_Vibe.startVibe(&fbb)
    hushh_hcf_Vibe.add(id: id, &fbb)
    hushh_hcf_Vibe.add(description: description, &fbb)
    hushh_hcf_Vibe.add(imageBase64: imageBase64, &fbb)
    hushh_hcf_Vibe.add(url: url, &fbb)
    return hushh_hcf_Vibe.endVibe(&fbb, start: __start)
  }
  

  public mutating func unpack() -> hushh_hcf_VibeT {
    return hushh_hcf_VibeT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_VibeT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_VibeT) -> Offset {
    let __id: Offset
    if let s = obj.id {
      __id = builder.create(string: s)
    } else {
      __id = Offset()
    }

    let __description: Offset
    if let s = obj.description {
      __description = builder.create(string: s)
    } else {
      __description = Offset()
    }

    let __imageBase64: Offset
    if let s = obj.imageBase64 {
      __imageBase64 = builder.create(string: s)
    } else {
      __imageBase64 = Offset()
    }

    let __url: Offset
    if let s = obj.url {
      __url = builder.create(string: s)
    } else {
      __url = Offset()
    }

    let __root = hushh_hcf_Vibe.startVibe(&builder)
    hushh_hcf_Vibe.add(id: __id, &builder)
    hushh_hcf_Vibe.add(description: __description, &builder)
    hushh_hcf_Vibe.add(imageBase64: __imageBase64, &builder)
    hushh_hcf_Vibe.add(url: __url, &builder)
    return hushh_hcf_Vibe.endVibe(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageBase64.p, fieldName: "imageBase64", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

extension hushh_hcf_Vibe: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
    case description = "description"
    case imageBase64 = "image_base64"
    case url = "url"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(id, forKey: .id)
    try container.encodeIfPresent(description, forKey: .description)
    try container.encodeIfPresent(imageBase64, forKey: .imageBase64)
    try container.encodeIfPresent(url, forKey: .url)
  }
}

public class hushh_hcf_VibeT: NativeObject {

  public var id: String?
  public var description: String?
  public var imageBase64: String?
  public var url: String?

  public init(_ _t: inout hushh_hcf_Vibe) {
    id = _t.id
    description = _t.description
    imageBase64 = _t.imageBase64
    url = _t.url
  }

  public init() {
  }

  public func serialize() -> ByteBuffer { return serialize(type: hushh_hcf_Vibe.self) }

}
public struct hushh_hcf_Catalog: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case version = 6
    case description = 8
    case products = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var version: String? { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.version.v) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var hasProducts: Bool { let o = _accessor.offset(VTOFFSET.products.v); return o == 0 ? false : true }
  public var productsCount: Int32 { let o = _accessor.offset(VTOFFSET.products.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func products(at index: Int32) -> hushh_hcf_Product? { let o = _accessor.offset(VTOFFSET.products.v); return o == 0 ? nil : hushh_hcf_Product(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startCatalog(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(version: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: version, at: VTOFFSET.version.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func addVectorOf(products: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: products, at: VTOFFSET.products.p) }
  public static func endCatalog(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCatalog(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    versionOffset version: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    productsVectorOffset products: Offset = Offset()
  ) -> Offset {
    let __start = hushh_hcf_Catalog.startCatalog(&fbb)
    hushh_hcf_Catalog.add(id: id, &fbb)
    hushh_hcf_Catalog.add(version: version, &fbb)
    hushh_hcf_Catalog.add(description: description, &fbb)
    hushh_hcf_Catalog.addVectorOf(products: products, &fbb)
    return hushh_hcf_Catalog.endCatalog(&fbb, start: __start)
  }
  

  public mutating func unpack() -> hushh_hcf_CatalogT {
    return hushh_hcf_CatalogT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_CatalogT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout hushh_hcf_CatalogT) -> Offset {
    let __id: Offset
    if let s = obj.id {
      __id = builder.create(string: s)
    } else {
      __id = Offset()
    }

    let __version: Offset
    if let s = obj.version {
      __version = builder.create(string: s)
    } else {
      __version = Offset()
    }

    let __description: Offset
    if let s = obj.description {
      __description = builder.create(string: s)
    } else {
      __description = Offset()
    }

    var __products__: [Offset] = []
    for var i in obj.products {
      __products__.append(hushh_hcf_Product.pack(&builder, obj: &i))
    }
    let __products = builder.createVector(ofOffsets: __products__)
    let __root = hushh_hcf_Catalog.startCatalog(&builder)
    hushh_hcf_Catalog.add(id: __id, &builder)
    hushh_hcf_Catalog.add(version: __version, &builder)
    hushh_hcf_Catalog.add(description: __description, &builder)
    hushh_hcf_Catalog.addVectorOf(products: __products, &builder)
    return hushh_hcf_Catalog.endCatalog(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.products.p, fieldName: "products", required: false, type: ForwardOffset<Vector<ForwardOffset<hushh_hcf_Product>, hushh_hcf_Product>>.self)
    _v.finish()
  }
}

extension hushh_hcf_Catalog: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
    case version = "version"
    case description = "description"
    case products = "products"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(id, forKey: .id)
    try container.encodeIfPresent(version, forKey: .version)
    try container.encodeIfPresent(description, forKey: .description)
    if productsCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .products)
      for index in 0..<productsCount {
        guard let type = products(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
  }
}

public class hushh_hcf_CatalogT: NativeObject {

  public var id: String?
  public var version: String?
  public var description: String?
  public var products: [hushh_hcf_ProductT?]

  public init(_ _t: inout hushh_hcf_Catalog) {
    id = _t.id
    version = _t.version
    description = _t.description
    products = []
    for index in 0..<_t.productsCount {
        var __v_ = _t.products(at: index)
        products.append(__v_?.unpack())
    }
  }

  public init() {
    products = []
  }

  public func serialize() -> ByteBuffer { return serialize(type: hushh_hcf_Catalog.self) }

}
